---
title: "Modelo de Regresión SLA's"
author: "Daniela Benavides Herrera"
date: "25/3/2021"
output: 
  html_notebook:
    theme: cerulean
    toc: TRUE
    toc_float: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```

```{r, message=FALSE}
library(tidyverse)
library(readxl)
library(tsibble)
library(feasts)
library(fable)
```

```{r}
source("eda_TR.R", local = knitr::knit_global(),encoding = "utf-8")
```

<center>
![](logo.png)
</center>

# Introducción

<div style="text-align: justify">

El propósito de este proyecto es generar un modelo de regresión a partir de los SLA's (Service Level Agreements), los cuales vamos a dividir principalmente en:

- **TR**: Tiempos de Respuesta 
- **TST**: Tiempos de Solución Total para el cliente
- **TMO**: Tiempos de Mano de Obra
- **TSP**: Tiempo de Solución Total para Exel Pitss

<div/>

# Modelo de Regresión

<div style="text-align: justify">

El modelo de regresión lineal nos permite crear una relación entre 2 variables:

- La variable de previsión $y$ o dependiente
- La variable predictora $x$ o regresora

Por lo tanto, a partir de esto es como vamos a realizar pronósticos. A continuación podemos ver un sencillo ejemplo de cómo ajustamos 2 variables, en este caso, el tiempo de solución total de Exel Pitss (TSP) y el tiempo de respuesta (TR).

<div/>

```{r}
datos %>% ggplot(aes(x = TR, y = TSP)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)
```
<div style="text-align: justify">

Por otra parte, para poder realizar los pronósticos, fue necesario agrupar los datos según la fecha de Recepción, seguido de la Ruta. La primera tabla a continuación, muestra los datos agrupados diariamente, la segunda los muestra agrupados semanalmente, y por último, la tercera, los muestra mensualmente.

<div/>
  
  * Diariamente

```{r}
datos_tsbl <- datos %>% filter(IS.visita != "Consultoria Dual",
         Estatus   == "RESUELTA",
         Categoría == "CORRECTIVO") %>% 
  group_by(Recepcion, Ruta) %>% 
  summarise(across(.cols = c(TR, TSP, TMO, TST), mean),
            .groups = "drop") %>% 
  pivot_longer(
    cols      = starts_with("T"),
    names_to  = "SLA", 
    values_to = "Tiempos"
  ) %>% 
  as_tsibble(
    # index : la variable temporal
    index = Recepcion,
    # key : la(s) variable(s) que identifican a cada serie de tiempo
    key   = c(Ruta, SLA) 
  ) %>% 
  fill_gaps(.full = TRUE, Tiempos = mean(Tiempos))

datos_tsbl
```

  * Semanalmente

```{r}
datos_week_tsbl <- datos_tsbl %>% 
  group_by_key() %>% 
  index_by(Semana = yearweek(Recepcion)) %>% 
  summarise(Tiempos = mean(Tiempos), .groups = "drop")
datos_week_tsbl
```
  * Mensualmente

```{r}
datos_month_tsbl <- datos_tsbl %>% 
  group_by_key() %>% 
  index_by(Mes = yearmonth(Recepcion)) %>% 
  summarise(Tiempos = mean(Tiempos), .groups = "drop")
datos_month_tsbl
```
## Visualización

A continuación se muestran las gráficas según la ruta y el tiempo de agrupamiento seleccionado.

```{r}
datos_tsbl %>%
  filter(Ruta == "JALISCO") %>%
  autoplot(Tiempos) + #aes(color = Ruta) +
  facet_wrap(~ SLA, scales = "free_y") +
  theme(legend.position = "none")



datos_week_tsbl %>% 
  filter(Ruta == "JALISCO") %>% 
  autoplot(Tiempos) + #aes(color = Ruta) +
  facet_wrap(~ SLA, scales = "free_y") +
  theme(legend.position = "none")



datos_month_tsbl %>% 
  filter(Ruta == "JALISCO") %>% 
  autoplot(Tiempos) + #aes(color = Ruta) +
  facet_wrap(~ SLA, scales = "free_y") +
  theme(legend.position = "none")


```


```{r}
# p <- datos_tsbl %>%
#   filter(Ruta == "JALISCO") %>%
#   autoplot(Tiempos) + #aes(color = Ruta) +
#   facet_wrap(~ SLA, scales = "free_y") +
#   theme(legend.position = "none")
# 
# plotly::ggplotly(p)
# 
# p <- datos_week_tsbl %>% 
#   filter(Ruta == "JALISCO") %>% 
#   autoplot(Tiempos) + #aes(color = Ruta) +
#   facet_wrap(~ SLA, scales = "free_y") +
#   theme(legend.position = "none")
# 
# plotly::ggplotly(p)
# 
# p <- datos_month_tsbl %>% 
#   filter(Ruta == "JALISCO") %>% 
#   autoplot(Tiempos) + #aes(color = Ruta) +
#   facet_wrap(~ SLA, scales = "free_y") +
#   theme(legend.position = "none")
# 
# plotly::ggplotly(p)
```

## Modelado

Se utilizó el modelo ETS y el modelo ARIMA para realizar un pronóstico de los SLA's, según el tiempo de agrupamiento.

```{r}
datos_tsbl %>% 
  filter(Ruta == "JALISCO") %>% 
  model(ETS(Tiempos),
        ARIMA(Tiempos)) %>% 
  forecast(h = "1 year") %>% 
  autoplot(datos_tsbl, level = NULL)+
  facet_wrap(~SLA, scales = "free_y")

datos_week_tsbl %>% 
  filter(Ruta == "JALISCO") %>% 
  model(ETS(Tiempos),
        ARIMA(Tiempos)) %>% 
  forecast(h = "1 year") %>% 
  autoplot(datos_week_tsbl, level = NULL)+
  facet_wrap(~SLA, scales = "free_y")

datos_month_tsbl %>% 
  filter(Ruta == "JALISCO") %>% 
  model(ETS(Tiempos),
        ARIMA(Tiempos)) %>% 
  forecast(h = "1 year") %>% 
  autoplot(datos_month_tsbl, level = NULL)+
  facet_wrap(~SLA, scales = "free_y")
```

